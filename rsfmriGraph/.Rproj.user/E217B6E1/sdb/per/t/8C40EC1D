{
    "contents" : "#' @title corCreate loops over a collection of csv files and creates correlations\n#' \n#' @description Reads a collection of csv files and puts them into a list of either \n#' correlations or covariances\n#' \n#' @details This function loops over a collection of csv files and then creates a \n#' matrix of vectorized covariance or correlation functions or a list of them.\n#'\n#' @author Brian Caffo\n#' @param filelist chararcter list of csv files\n#' @param loadFunction the function used to load in the files (defaults to read.csv)\n#' @param transpose whether or not to transpose the date before creating the correlations\n#' @param what function that is used to create matrix, obvious candidates are \\code{\\link{cor}} \\code{{link(cov)}}\n#' @param asMatrix each correlation run through cor2vec and stacked up as a matrix? Otheriwse dump everything into a list\n#' @param columns use only specific columns of the csv files\n#' @param columnNames character vectror of names \n#' @param cores parallelize the computation, only needed if \\code{what} is something computationally intensive, otherwise it will slow things down\n#' @export\n#' @seealso cor2vec\n#' @return returns a matrix or list of output from what\n#' @keywords cor\n\ncorCreate <- function(fileList, path = \"./\", \n                      loadFunction = read.csv, \n                      transpose = FALSE,\n                      what = cor, \n                      asMatrix = TRUE, \n                      columns = NULL, \n                      columnNames = NULL,\n                      cores = 1, \n                      ...){\n\n    ##the fileList with the paths appended\n    filesFullPath <- paste(path, \"/\", fileList, sep = \"\")\n    \n    ##stop if the files don't all exist\n    stopifnot(all(sapply(filesFullPath, file.exists)))\n    \n    ##read in the data\n    dat <- lapply(filesFullPath, function(filename) loadFunction(filename, ...)) \n    \n    if (transpose) dat <- lapply(dat, t)\n    \n    ##check to make sure everything has the same number of columns\n    cols <- sapply(dat, ncol)\n    if (length(unique(cols)) > 1) {\n        print(data.frame(file = filesFullPath, columns = cols))\n        stop(\"Files do not all have the same number of columns\")\n    }\n    \n    \n    ##if no columns are specified use all\n    if (!is.null(columns)) {\n        dat <- lapply(dat, function(datEl) datEl[, columns])\n    }\n    else columns <- 1 : cols[1]\n\n    ##apply the column names if asked\n    if (!is.null(columnNames)){\n        if (length(columnNames) != length(columns)){\n            stop(\"columnNames of a different length than the number of specified columns\")\n        }\n        dat <- lapply(dat, function(datEl) {colnames(datEl) <- columnNames; datEl})\n    }\n    \n    if (cores > 1) {\n        cl <- makeCluster(getOption(\"cl.cores\", cores))\n        out <- parLapply(cl, dat, what)\n    }\n    else if (cores == 1) {\n        out <- lapply(dat, what)\n    }\n    names(out) <- fileList    \n    \n    if (asMatrix) out <- t(sapply(out, cor2vec))\n    \n    if (cores > 1) stopCluster(cl)\n    \n    return(out)\n}\n",
    "created" : 1398875537106.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1831822078",
    "id" : "8C40EC1D",
    "lastKnownWriteTime" : 1398877140,
    "path" : "~/R/rsfmriGraph/R/corCreate.R",
    "project_path" : "R/corCreate.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}